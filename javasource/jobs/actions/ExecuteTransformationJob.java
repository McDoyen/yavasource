// This file was generated by Mendix Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package jobs.actions;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import jobs.worker.TransformationWorker;
import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import com.mendix.systemwideinterfaces.core.IMendixObject;

/**
 * [3833] Added java action to start a transformation job.
 * The java action checks if the TransformationJobs and configurations StartTime and EndTime itself if it may start, and updates these attributes during the process.
 */
public class ExecuteTransformationJob extends CustomJavaAction<java.lang.Boolean>
{
	private IMendixObject __InputJob;
	private jobs.proxies.TransformationJob InputJob;

	public ExecuteTransformationJob(IContext context, IMendixObject InputJob)
	{
		super(context);
		this.__InputJob = InputJob;
	}

	@Override
	public java.lang.Boolean executeAction() throws Exception
	{
		this.InputJob = __InputJob == null ? null : jobs.proxies.TransformationJob.initialize(getContext(), __InputJob);

		// BEGIN USER CODE
		if(this.InputJob == null) {
			error("No input object");
			return false;
		}
		if(this.InputJob.getStartTime() != null && this.InputJob.getEndTime() == null){
			error("Job ["+this.InputJob.getName()+"] is already running!");
			return false;
		}
		if(this.InputJob.getName() == null || this.InputJob.getName().equals("")){
			error("Job name not set, or empty string");
			return false;
		}
		
		this.InputJob.setStartTime(new Date());
		this.InputJob.setEndTime(null);
		IContext sysContext = Core.createSystemContext();

		commitNow(sysContext, this.InputJob.getMendixObject());
		log("Job start time set");
		
		// get configurations
		// find a way to no remove hardcoded reference
		List<IMendixObject>configList = Core.retrieveByPath(getContext(), __InputJob, jobs.proxies.TransformationConfig.MemberNames.TransformationJobConfig.toString());
		int poolThreads = (this.InputJob.getThreads() > 0) ? this.InputJob.getThreads(): 1;

		ExecutorService executor = Executors.newFixedThreadPool(poolThreads);
		List<Future<Boolean>> poolFutures = new ArrayList<Future<Boolean>>();
		log("Pool of ["+poolThreads+"] created");
		int queueLimit = this.InputJob.getQueueLimit().intValue() > 50 && this.InputJob.getQueueLimit().intValue() <= 5000 ? this.InputJob.getQueueLimit().intValue(): 1000;
		
		for(IMendixObject jobConfig:configList){
			jobs.proxies.TransformationConfig jconfig = jobs.proxies.TransformationConfig.initialize(getContext(), jobConfig);
			if(jconfig.getEntityName() == null || jconfig.getEntityName().equals("") || jconfig.getAttributeNames().equals("") || jconfig.getAttributeNames() == null){
				error("Job configuration ["+jconfig.getMendixObject().getId().toLong()+"] has no entity and/or attributes set to transform");
				continue;
			}
			if(jconfig.getEndTime() == null && jconfig.getStartTime() != null) {
				error("Job configuration["+jconfig.getMendixObject().getId().toLong()+"] for entity ["+jconfig.getEntityName()+"] is already running");
				continue;
			}
			jconfig.setEndTime(null);
			jconfig.setStartTime(new Date());
			//jconfig.commit();
			commitNow(sysContext, jconfig.getMendixObject());
			

			String xpath = (jconfig.getConstraint() == null) ? "//"+jconfig.getEntityName(): "//"+jconfig.getEntityName()+"["+jconfig.getConstraint()+"]";

			long count = Core.retrieveXPathQueryAggregate(getContext(), "count(" + xpath + ")");
			int loop = (int) Math.ceil(((float) count) / ((float) this.InputJob.getBatchSize().intValue()));
			log(count + " objects divided over " + loop + " batches (" + this.InputJob.getBatchSize().intValue() + " items per list).");
			int offset = 0;
					
			for (int i = 0; i < loop; i++) {
				log("Create Worker #"+i);
				Callable<Boolean> worker = new TransformationWorker((jconfig.getOptions() == jobs.proxies.TransformationOptions.Fully_random), jconfig.getEntityName(), jconfig.getConstraint(), this.InputJob.getBatchSize().intValue(), offset, jconfig.getAttributeNames().split(","));
				offset += this.InputJob.getBatchSize().intValue();
			    poolFutures.add(executor.submit(worker));
				if(poolFutures.size() >= queueLimit){
					finishCurrentWorkers(poolFutures);
					poolFutures.clear();
				}
			}

			finishCurrentWorkers(poolFutures);
			poolFutures.clear();

			jconfig.setEndTime(new Date());
			commitNow(sysContext, jconfig.getMendixObject());
		}
		this.InputJob.setEndTime(new Date());
		this.InputJob.commit();

		executor.shutdown();
		while (!executor.isTerminated()) {}
		
		log("Finished Transformation Job ["+this.InputJob.getName()+"] execution");
		return true;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@Override
	public java.lang.String toString()
	{
		return "ExecuteTransformationJob";
	}

	// BEGIN EXTRA CODE

	private void commitNow(IContext context, IMendixObject mxObj){
		List<IMendixObject> asynList = new ArrayList<IMendixObject>();
		asynList.add(mxObj);
		List<Future<List<IMendixObject>>> fConfigCommit = Core.commitAsync(context, asynList);
		for(Future<List<IMendixObject>> fList: fConfigCommit){
			try {
				fList.get();
			} catch (InterruptedException e) {
            	error("Encountered InterruptedException: "+getFullStackTrace(e,0));    
			} catch (ExecutionException e) {
            	error("Encountered ExecutionException: "+getFullStackTrace(e,0));
			}
		}
	}
	private void finishCurrentWorkers(List<Future<Boolean>> futureList){
		for(Future<Boolean> thisFuture: futureList){
			try {
				thisFuture.get();
            } catch (ExecutionException e) {
            	error("Encountered ExecutionException: "+getFullStackTrace(e,0));
            } catch (InterruptedException e) {
            	error("Encountered InterruptedException: "+getFullStackTrace(e,0));            	
			}
		}
	}
	public static StringBuilder getFullStackTrace(Throwable e, int level) {
		StackTraceElement[] stes = e.getStackTrace();
		StringBuilder stackTrace = new StringBuilder(1000); 
		stackTrace.append(e.getClass().getName()).append(":");
		if (e.getMessage()!=null) stackTrace.append(e.getMessage());
		stackTrace.append("\n\n");
		if (stes!=null) {
			for(StackTraceElement ste:stes) {
				stackTrace.append("\n  ").append(ste.getClassName()).append(".").append(ste.getMethodName()).append(" (").append(ste.getFileName()).append(":").append(ste.getLineNumber()).append( ")");
			}
		}
		if (e.getCause()!=null) {
			if (level<20)
				stackTrace.append(getFullStackTrace(e.getCause(), level+1));
		}
		return stackTrace;
	}
	private void log(String input){
		Core.getLogger("ExpertDesk").debug("[job."+this.toString()+"] " + input);
	}
	private void error(String input){
		Core.getLogger("ExpertDesk").error("[job."+this.toString()+"] " + input);
	}
	// END EXTRA CODE
}
