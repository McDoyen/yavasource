// This file was generated by Mendix Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package mendix.actions;

import java.io.File;
import java.util.HashMap;
import java.util.Map;
import mendix.proxies.XSSSanitizeConfig;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;
import org.owasp.validator.html.AntiSamy;
import org.owasp.validator.html.CleanResults;
import org.owasp.validator.html.Policy;
import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import communitycommons.XPath;
import communitycommons.proxies.XSSPolicy;

/**
 * Removes all potiential dangerous HTML from a string so that it can be safely displayed in a browser. Excludes inline images to avoid MaxInputSize of 100k byes.
 * 
 * Additionally all <a> attributes get a default target of _blank to avoid going outside application by clicking a link.
 * 
 * This function should be applied to all HTML which is displayed in the browser, and can be entered by (untrusted) users.
 * 
 * - HTML: The html to sanitize
 * - policy: The policy that defines the allowed HTML tags a user is allowd to use:
 * 
 * (see the developers guide in the resources folder for more details about the policies)
 * 
 * TinyMCE: Based on the HTML WYSIWYG editor, relatively safe. This policy file only allows text formatting, and may be a good choice if users are submitting HTML to be used in a blog post.
 * 
 * Allow anything: A very dangerous policy file, this will allow all HTML, CSS and JavaScript. You shouldn't use this in production.
 * 
 * Ebay: Based on the content filtering for the popular electronic auction website, relatively safe. This policy file gives the user a little bit of freedom, and may be a good choice if users are submitting HTML for a large portion of a page.
 * 
 * MySpace: Based on the content filtering for the popular social networking site, relatively dangerous. This policy file gives the user a lot of freedom, and may be a good choice if users are submitting HTML for an entire page.
 * 
 * Slashdot: Based on the comment filtering on the popular news site, but not quite as strict. This policy file only allows strict text formatting, and may be a good choice if users are submitting HTML in a comment thread.
 * 
 * BootstrapRTE: Based on TinyMCE and allows hyperlinks and embedded images. Basically allows what the Bootstrap Rich Text widget provides.
 */
public class XSSSanitizeAdvanced extends CustomJavaAction<java.lang.String>
{
	private java.lang.String html;
	private communitycommons.proxies.XSSPolicy policy;

	public XSSSanitizeAdvanced(IContext context, java.lang.String html, java.lang.String policy)
	{
		super(context);
		this.html = html;
		this.policy = policy == null ? null : communitycommons.proxies.XSSPolicy.valueOf(policy);
	}

	@Override
	public java.lang.String executeAction() throws Exception
	{
		// BEGIN USER CODE
		if (html == null || html.isEmpty())
			return "";	
		
		Document docOrig = Jsoup.parse(html);
		Elements imagesOrig = docOrig.select("img");		
		int imageCount = 0;
		Map<String, String> b64images = new HashMap<String, String>();
		
		for (Element image : imagesOrig) {
			String imageSource = image.attr("src");
			
			// check for targetted image type
			int dataAt = imageSource.indexOf("data");
			if (dataAt == -1) continue;
			
			int imageAt = imageSource.indexOf(":");
			if (imageAt == -1) continue;
			imageAt++;
			
			int base64At = imageSource.indexOf(";base64", dataAt);
			if (base64At == -1) continue;
			
			String file_id = "tmp_img_" + imageCount++;
			
			b64images.put(file_id, imageSource);
			image.attr("src", "data:image/jpg;" + file_id);
		}
		
		String temp_html = docOrig.outerHtml();
		String sanitizedHTML = XSSSanitize(temp_html, policy);
		
		Document docSanitized = Jsoup.parse(sanitizedHTML);
		
		for (Map.Entry<String, String> entry : b64images.entrySet()) {
			
			Element currentImage = docSanitized.select("img[src$=data:image/jpg;"+ entry.getKey() +"]").first();
			currentImage.attr("src", entry.getValue());
		}
		
		// set <a target="_blank".. for all links to avoid links opening in current browser window
		
		docSanitized.select("a").attr("target", "_target");
		Elements wwwlinks = docSanitized.select("a[href^=www]");
		for (Element link : wwwlinks) {
			String href = link.attr("href");
			link.attr("href", "http://" + href);
		}
		
		return docSanitized.outerHtml();
		
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@Override
	public java.lang.String toString()
	{
		return "XSSSanitizeAdvanced";
	}

	// BEGIN EXTRA CODE
	
	public static String XSSSanitize(String html, XSSPolicy policy)
			throws Exception {
		if (html == null)
			return "";
		// return HtmlSanitizer.sanitize(html);
		String policyString = policy == null ? "tinymce" : policy.toString()
				.toLowerCase();
		return XSSSanitize(html, policyString);
	}
	
	public static String XSSSanitize(String html, String policyString)
			throws Exception {
		if (html == null)
			return "";
		if (policyString == null)
			throw new Exception("Unable to perform XSS sanitization: policyString is null");
		
		String filename = Core.getConfiguration().getResourcesPath() + File.separator
				+ "communitycommons" + File.separator + "antisamy"
				+ File.separator + "antisamy-" + policyString + "-1.4.4.xml";
		
		XPath<XSSSanitizeConfig> xssConfigXpath = XPath.create(Core.createSystemContext(), XSSSanitizeConfig.class);
		XSSSanitizeConfig xssConfig = xssConfigXpath.first();
	
		AntiSamy as = new AntiSamy(); // Create AntiSamy object
		
		Policy p = Policy.getInstance(filename);
		
		p = p.cloneWithDirective("maxInputSize", xssConfig.getmaxInputSize().toString());
		p = p.cloneWithDirective("formatOutput", xssConfig.getformatOutput().toString());
		p = p.cloneWithDirective("preserveSpace", xssConfig.getpreserveSpace().toString());
		p = p.cloneWithDirective("preserveComments", xssConfig.getpreserveComments().toString());
		
		try {
			CleanResults cr = as.scan(html, p, AntiSamy.SAX);
			return cr.getCleanHTML();
		} catch (Exception e) {
			throw new Exception("Unable to perform XSS sanitization: "
					+ e.getMessage(), e);
		}
	}
	
	// END EXTRA CODE
}
