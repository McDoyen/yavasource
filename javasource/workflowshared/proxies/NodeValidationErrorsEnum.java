// This file was generated by Mendix Modeler.
//
// WARNING: Code you write here will be lost the next time you deploy the project.

package workflowshared.proxies;

public enum NodeValidationErrorsEnum
{
	TooManyInputs(new java.lang.String[][] { new java.lang.String[] { "en_US", "Node has too many incoming links." }, new java.lang.String[] { "nl_NL", "Deze node heeft te veel inkomende relaties" }, new java.lang.String[] { "de_DE", "Knoten hat zu viele eingehende Links." } }),
	TooManyOutputs(new java.lang.String[][] { new java.lang.String[] { "en_US", "Node has too many outgoing links." }, new java.lang.String[] { "nl_NL", "Deze node heeft teveel uitgaande relaties" }, new java.lang.String[] { "de_DE", "Knoten hat zu viele ausgehende Links." } }),
	NeedInput(new java.lang.String[][] { new java.lang.String[] { "en_US", "Node needs an incoming link." }, new java.lang.String[] { "nl_NL", "Node heeft een inkomende relatie nodig" }, new java.lang.String[] { "de_DE", "Knoten braucht einen eingehenden Link." } }),
	NeedOutput(new java.lang.String[][] { new java.lang.String[] { "en_US", "Node needs an outgoing link." }, new java.lang.String[] { "nl_NL", "Node heeft een uitgaande relatie nodig" }, new java.lang.String[] { "de_DE", "Knoten braucht einen ausgehenden Link." } }),
	NodeNoStart(new java.lang.String[][] { new java.lang.String[] { "en_US", "Node is not reached by start node." }, new java.lang.String[] { "nl_NL", "De node kan niet bereikt worden door de startnode" }, new java.lang.String[] { "de_DE", "Knoten hat keine Verbindung zum Startknoten" } }),
	NodeNoEnd(new java.lang.String[][] { new java.lang.String[] { "en_US", "Node does not reach an end node." }, new java.lang.String[] { "nl_NL", "De node kan de eindnode niet bereiken" }, new java.lang.String[] { "de_DE", "Knoten hat keine Verbindung zum Endknoten" } }),
	ParallelNoEnd(new java.lang.String[][] { new java.lang.String[] { "en_US", "Not all nodes after the parallel node reach the end." }, new java.lang.String[] { "nl_NL", "Niet alle nodes na de parallelle node kunnen het einde bereiken." }, new java.lang.String[] { "de_DE", "Nicht alle Knoten hinter dem Parallelknoten haben eine Verbindung zum Endknoten." } }),
	ConditionNodeMissingConditions(new java.lang.String[][] { new java.lang.String[] { "en_US", "Condition node needs condition on all outgoing links" }, new java.lang.String[] { "nl_NL", "Conditionele node heeft conditie nodig voor alle uitgaande relaties" }, new java.lang.String[] { "de_DE", "Bedingungsknoten benötigt Bedingungen für alle abgehenden Links." } }),
	ConditionNoOther(new java.lang.String[][] { new java.lang.String[] { "en_US", "Condition node needs exactly one condition 'Other' on one of the outgoing links." }, new java.lang.String[] { "nl_NL", "Conditonele node heeft de conditie 'Anders' nodig op een van de uitgaande relaties" }, new java.lang.String[] { "de_DE", "Bedingungsknoten benötigt Bedingung \"Andere\" für mindestens einen abgehenden Link" } }),
	Condition_has_errors(new java.lang.String[][] { new java.lang.String[] { "en_US", "Condition has errors" }, new java.lang.String[] { "nl_NL", "De conditie bevat fouten." }, new java.lang.String[] { "de_DE", "Bedingung fehlerhaft" } }),
	MergeNodeOrdeError(new java.lang.String[][] { new java.lang.String[] { "en_US", "Merge Node Order Needs to be less than the amount of incoming Links." }, new java.lang.String[] { "nl_NL", "Merge node order moet kleiner zijn dan het aantal binnenkomende relaties" }, new java.lang.String[] { "de_DE", "Ein Merge-Knoten-Auftrag muss kleiner sein als die Anzahl der eingehenden Links" } }),
	EndNodeError(new java.lang.String[][] { new java.lang.String[] { "en_US", "End Node Needs Result" }, new java.lang.String[] { "de_DE", "Endknoten benötigt ein Ergebnis." }, new java.lang.String[] { "nl_NL", "Eindnode heeft een resultaat nodig." } }),
	MergeNodeConditionTypeRequired(new java.lang.String[][] { new java.lang.String[] { "en_US", "Merge Node needs a merge condition type" }, new java.lang.String[] { "nl_NL", "Merge node heeft een merge conditietype nodig" }, new java.lang.String[] { "de_DE", "Merge-Knoten braucht einen Merge-Bedingungstyp" } }),
	TaskNodeTaskTemplateError(new java.lang.String[][] { new java.lang.String[] { "en_US", "Request Node has no task template or task template with wrong process type or no OLA contract" }, new java.lang.String[] { "nl_NL", "Verzoeknode heeft geen taaktemplate of een taaktemplate met een verkeerd proces of OLA contract." }, new java.lang.String[] { "de_DE", "Dem Anfrageknoten wurde kein Task-Template oder ein Task-Template mit falschem Prozesstyp oder ohne OLA-Vertrag zugewiesen." } }),
	TicketNodeTicketTemplateError(new java.lang.String[][] { new java.lang.String[] { "en_US", "Request Node has no ticket template or ticket template without SLA contract" }, new java.lang.String[] { "de_DE", "Dem Anfrageknoten wurde kein TicketTemplate oder ein Ticket-Template ohne SLA-Vertrag zugewiesen." }, new java.lang.String[] { "nl_NL", "Verzoeknode heeft geen verzoektemplate of een template zonder SLA contract." } }),
	SubWorkflowNodeError(new java.lang.String[][] { new java.lang.String[] { "en_US", "Sub workflow node has no (valid) sub workflow or sub workflow with wrong process type or business groups" }, new java.lang.String[] { "nl_NL", "Subworkflow is niet geldig of heeft incorrecte zakengroepen of procestypen." }, new java.lang.String[] { "de_DE", "Sub workflow node has no (valid) sub workflow or sub workflow with wrong process type or business groups" } }),
	Sub_Workflow_Deleted(new java.lang.String[][] { new java.lang.String[] { "en_US", "Sub Workflow Deleted" }, new java.lang.String[] { "de_DE", "Sub-Workflow gelöscht" }, new java.lang.String[] { "nl_NL", "Subworkflow is verwijderd" } }),
	Action_Node_Error(new java.lang.String[][] { new java.lang.String[] { "en_US", "Action Node needs action to be in Matrix of workflow." }, new java.lang.String[] { "nl_NL", "De actienode moet onderdeel zijn van de matrix van de workflow." }, new java.lang.String[] { "de_DE", "Dem Aktionsknoten muss eine Aktion zugewiesen werden, um ein Workflow in der Matrix zu sein." } }),
	Message_Node_Error(new java.lang.String[][] { new java.lang.String[] { "en_US", "Message Node needs a type and an email or outgoing interface message template." }, new java.lang.String[] { "de_DE", "Nachricht Knoten braucht eine Art und eine E-Mail oder ausgehende Schnittstelle Nachricht-Vorlage." }, new java.lang.String[] { "nl_NL", "Berichtnode heeft een type nodig en een e-mailtemplate bericht of een uitgaande interface-bericht template." } }),
	Approval_Node_Error(new java.lang.String[][] { new java.lang.String[] { "en_US", "Approval Node needs Approval Template." }, new java.lang.String[] { "de_DE", "Abnahme-Knoten bedarf eines Abnahme-Templates" }, new java.lang.String[] { "nl_NL", "Goedkeuringsnode heeft een goedkeuringstemplate nodig." } }),
	TimerNodeError(new java.lang.String[][] { new java.lang.String[] { "en_US", "Timer Node Needs Duration" }, new java.lang.String[] { "de_DE", "Dem Zeitmesser-Knoten muss eine Dauer zugewiesen werden." }, new java.lang.String[] { "nl_NL", "Timernode heeft een duur nodig" } }),
	CancelNodeError(new java.lang.String[][] { new java.lang.String[] { "en_US", "Cancel Node Needs Type and for Type Node Cancel a Node" }, new java.lang.String[] { "de_DE", "Alle Knoten-Bedarfs-Typ und für Typ Knoten-Abbruch abbrechen." }, new java.lang.String[] { "nl_NL", "Annuleernode heeft een annuleertype nodig en als het annuleertype een node is dan is een annuleernode ook nodig" } }),
	SignalNodeError(new java.lang.String[][] { new java.lang.String[] { "en_US", "Signal Node needs Signal" }, new java.lang.String[] { "de_DE", "Impuls-Knoten benötigt ein Impuls" }, new java.lang.String[] { "nl_NL", "Signaalnode heeft een signaal nodig" } });

	private java.util.Map<java.lang.String, java.lang.String> captions;

	private NodeValidationErrorsEnum(java.lang.String[][] captionStrings)
	{
		this.captions = new java.util.HashMap<java.lang.String, java.lang.String>();
		for (java.lang.String[] captionString : captionStrings)
			captions.put(captionString[0], captionString[1]);
	}

	public java.lang.String getCaption(java.lang.String languageCode)
	{
		if (captions.containsKey(languageCode))
			return captions.get(languageCode);
		return captions.get("en_US");
	}

	public java.lang.String getCaption()
	{
		return captions.get("en_US");
	}
}
