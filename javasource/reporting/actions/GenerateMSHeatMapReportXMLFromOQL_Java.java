// This file was generated by Mendix Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package reporting.actions;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.TimeZone;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.DataFormat;
import org.apache.poi.ss.usermodel.Font;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.DateFormatConverter;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import nl.mansystems.mendiximportexport.SharedFunctions;
import reporting.proxies.TimePeriodEnum;
import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.connectionbus.data.IDataRow;
import com.mendix.systemwideinterfaces.connectionbus.data.IDataTable;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;

/**
 * ColumnList and PeriodList need to be semi-colon separated
 */
public class GenerateMSHeatMapReportXMLFromOQL_Java extends CustomJavaAction<java.lang.String>
{
	private java.lang.String OQLString;
	private java.lang.String ColumnList;
	private java.lang.String PeriodColumn;
	private java.lang.String PeriodList;
	private reporting.proxies.TimePeriodEnum TimePeriod;
	private java.lang.Boolean GenerateExcel;
	private IMendixObject __ReportSelectParameter;
	private reporting.proxies.ReportSelect ReportSelectParameter;
	private java.lang.String EmptyString;

	public GenerateMSHeatMapReportXMLFromOQL_Java(IContext context, java.lang.String OQLString, java.lang.String ColumnList, java.lang.String PeriodColumn, java.lang.String PeriodList, java.lang.String TimePeriod, java.lang.Boolean GenerateExcel, IMendixObject ReportSelectParameter, java.lang.String EmptyString)
	{
		super(context);
		this.OQLString = OQLString;
		this.ColumnList = ColumnList;
		this.PeriodColumn = PeriodColumn;
		this.PeriodList = PeriodList;
		this.TimePeriod = TimePeriod == null ? null : reporting.proxies.TimePeriodEnum.valueOf(TimePeriod);
		this.GenerateExcel = GenerateExcel;
		this.__ReportSelectParameter = ReportSelectParameter;
		this.EmptyString = EmptyString;
	}

	@Override
	public java.lang.String executeAction() throws Exception
	{
		this.ReportSelectParameter = __ReportSelectParameter == null ? null : reporting.proxies.ReportSelect.initialize(getContext(), __ReportSelectParameter);

		// BEGIN USER CODE
		IContext context = this.getContext();
		
		Workbook wb = null;
		Sheet sheet = null;
		Row headerRow = null;
		CellStyle csHeader = null;
		CellStyle csString = null;
		CellStyle csDate = null;

		if (GenerateExcel) {
			wb = new SXSSFWorkbook();
			csHeader = wb.createCellStyle();
			Font fontHeader = wb.createFont();
			fontHeader.setBoldweight(Font.BOLDWEIGHT_BOLD);
			csHeader.setFont(fontHeader);

			csString = wb.createCellStyle();
			csDate = wb.createCellStyle();
			Font fontBody = wb.createFont();
			fontBody.setFontHeightInPoints((short) 11);
			csString.setFont(fontBody);
			csDate.setFont(fontBody);

			Locale locale = Locale.getDefault();
			DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, locale);
			String javaDateFormatPattern = ((SimpleDateFormat)dateFormat).toPattern();
		    String excelFormatPattern = DateFormatConverter.convert(locale, javaDateFormatPattern);
			DataFormat dfDate = wb.createDataFormat();
			csDate.setDataFormat(dfDate.getFormat(excelFormatPattern));

			sheet = wb.createSheet("Results");
			headerRow = sheet.createRow(0);
			Cell cell = headerRow.createCell(0);
			cell.setCellValue(PeriodColumn);
			cell.setCellStyle(csHeader);
		}
		
		Core.getLogger("DynamicOQL").debug("Retrieving data");
		if (PeriodList!=null) Core.getLogger("DynamicOQL").trace("PeriodList:" + PeriodList);
		Core.getLogger("DynamicOQL").trace("OQL:" + OQLString);
		IDataTable iDataTable = Core.retrieveOQLDataTable(context, OQLString);
		String[] columns = ColumnList.split(";");
		boolean hasPeriodRange = false;
		int periodIndex=0;
		String[] periods=null;
		if (PeriodList!=null) {
			periods = PeriodList.split(";");
			hasPeriodRange = true;
		}
		Map<String,Integer> seriesExcelColumn = new HashMap<String,Integer>();
		int excelColumnNumber=1;
		
		StringBuffer rowSet = new StringBuffer();
		StringBuffer columnSet = new StringBuffer();
		StringBuffer dataSet = new StringBuffer();
		for (String column:columns) {
			if (iDataTable.getSchema().hasColumn(column)) {
				if (column.equals(PeriodColumn)) {
					//
				} else {
					rowSet.append("<row id='"+replaceSpecialCharacters(column)+"'/>\n");
					if (GenerateExcel) {
						Cell cell = headerRow.createCell(excelColumnNumber);
						cell.setCellValue(column);
						cell.setCellStyle(csHeader);						
						seriesExcelColumn.put(column, excelColumnNumber);
						excelColumnNumber++;
					}
				}
			} else {
				Core.getLogger(this.toString()).warn("Column " + column + " not found in data set.");
			}
		}

		
		int excelRowNumber=1;
		Row excelRow = null;
		String groupByStr = "";
		Long maxValue=0L;
		for (IDataRow dataRow:iDataTable.getRows()) {
			Object object2 = dataRow.getValue(context, PeriodColumn);
			groupByStr = (object2==null?EmptyString:object2.toString());
			if(!(groupByStr.equals(EmptyString)) && TimePeriod!=null){
				String yearStr = groupByStr.substring(0,4);
				if (TimePeriod == TimePeriodEnum.Year) {
					groupByStr = yearStr;
				}else if (TimePeriod == TimePeriodEnum.Quarter) {
					String monthStr = groupByStr.substring(4,5);
					groupByStr = yearStr + "-" + monthStr;
				}else if (TimePeriod == TimePeriodEnum.Month) {
					String monthStr = groupByStr.substring(4,6);
					groupByStr = yearStr + "-" + monthStr;
				}else if(TimePeriod == TimePeriodEnum.Week){
					String weekStr = groupByStr.substring(4,6);
					groupByStr = yearStr + "-" + weekStr;
				}else if (TimePeriod == TimePeriodEnum.Day) {	
					String monthStr = groupByStr.substring(4,6);
					String dayStr =  groupByStr.substring(6,8);
					groupByStr = yearStr + "-" + monthStr + "-" + dayStr;
				}else if (TimePeriod == TimePeriodEnum.Hour) {	
					String monthStr = groupByStr.substring(4,6);
					String dayStr =  groupByStr.substring(6,8);
					String hourStr =  groupByStr.substring(8,10);
					groupByStr = yearStr + "-" + monthStr + "-" + dayStr + " " + hourStr;
				}else if (TimePeriod == TimePeriodEnum.Minute) {	
					String monthStr = groupByStr.substring(4,6);
					String dayStr =  groupByStr.substring(6,8);
					String hourStr =  groupByStr.substring(8,10);
					String minuteStr =  groupByStr.substring(10,12);
					groupByStr = yearStr + "-" + monthStr + "-" + dayStr + " " + hourStr + ":" + minuteStr;
				}else if (TimePeriod == TimePeriodEnum.Second) {	
					String monthStr = groupByStr.substring(4,6);
					String dayStr =  groupByStr.substring(6,8);
					String hourStr =  groupByStr.substring(8,10);
					String minuteStr =  groupByStr.substring(10,12);
					String secondStr =  groupByStr.substring(12,14);
					groupByStr = yearStr + "-" + monthStr + "-" + dayStr + " " + hourStr + ":" + minuteStr + ":" + secondStr;
				}	
			}
			/*
			 * Fill gaps
			 */
			while (hasPeriodRange && periodIndex < periods.length && periods[periodIndex].compareTo(groupByStr)<0) {
				columnSet.append( "<column id='" + replaceSpecialCharacters(periods[periodIndex]) + "' />\n");
				Row gapRow = null;
				if (GenerateExcel) {
					gapRow = sheet.createRow(excelRowNumber);
					excelRowNumber++;
					gapRow.createCell(0).setCellValue(periods[periodIndex]);
				}
				for (String column2:columns) {
					if (iDataTable.getSchema().hasColumn(column2)) {
						if (!column2.equals(PeriodColumn)) {
							dataSet.append( "<set rowId='"+replaceSpecialCharacters(column2)+ "' columnId='"+replaceSpecialCharacters(periods[periodIndex])+"' value='0' />\n");									
							if (GenerateExcel) {
								gapRow.createCell(seriesExcelColumn.get(column2)).setCellValue(0);
							}
						}
					}
				}
				periodIndex++; // end on the current
			}
			periodIndex++; // every time there is no gap the periodIndex needs to advance.
			/*
			 * End fill gaps
			 */
			columnSet.append( "<column id='" + replaceSpecialCharacters(groupByStr) + "' />\n");
			if (GenerateExcel) {
				excelRow = sheet.createRow(excelRowNumber);
				excelRowNumber++;
				excelRow.createCell(0).setCellValue(groupByStr);
			}
			/*
			 * Now loop over the other columns
			 */
			for (String column:columns) {
				if (iDataTable.getSchema().hasColumn(column)) {
					Object value = dataRow.getValue(context, column);
					String valueStr = getValueString(value);
					if (!column.equals(PeriodColumn)) {
						if (value instanceof Long) {
							Long longValue = (Long) value;
							if (longValue>maxValue) maxValue=longValue;
						} else if (value instanceof Integer) {
							Integer intValue = (Integer) value;
							if (intValue>maxValue) maxValue=intValue.longValue();
						} else if (value instanceof Float) {
							Float floatValue = (Float) value;
							if (floatValue.longValue()>maxValue) maxValue=floatValue.longValue();
						} else if (value instanceof Double) {
							Double doubleValue = (Double) value;
							if (doubleValue.longValue()>maxValue) maxValue=doubleValue.longValue();
						} else {
							Core.getLogger(this.toString()).warn("Unsupported value type in result set: " + value.getClass().getName());
						}
						dataSet.append( "<set rowId='"+replaceSpecialCharacters(column)+ "' columnId='"+replaceSpecialCharacters(groupByStr)+"' value='"+valueStr
								+"' link=\"JavaScript:fusionCallback('#widgetid#','drillDown','"+replaceSpecialCharacters2(groupByStr)+","+replaceSpecialCharacters2(column)+","+valueStr+"');\" />\n");
						if (GenerateExcel) {
							Cell cell = excelRow.createCell(seriesExcelColumn.get(column));
							if( value==null) {
								cell.setCellValue(EmptyString);
								cell.setCellStyle(csString);
							} else if(value instanceof String) {
								cell.setCellValue((String)value);
								cell.setCellStyle(csString);
							} else if( value instanceof Date) {
								cell.setCellValue((Date)value);
								cell.setCellStyle(csDate);
							} else if( value instanceof Integer) {
								cell.setCellValue((Integer)value);
								cell.setCellStyle(csString);
							} else if( value instanceof Long) {
								cell.setCellValue((Long)value);
								cell.setCellStyle(csString);
							} else if( value instanceof Boolean) {
								cell.setCellValue((Boolean)value);
								cell.setCellStyle(csString);
							} else if( value instanceof Float) {
								cell.setCellValue((Float)value);
								cell.setCellStyle(csString);
							} else {
								cell.setCellValue(value.toString());
								cell.setCellStyle(csString);
							}

						}
					}
				}
			}
		}
		
		while (hasPeriodRange && periodIndex < periods.length && periods[periodIndex].compareTo(groupByStr)>=0) {
			columnSet.append( "<column id='" + replaceSpecialCharacters(periods[periodIndex]) + "' />\n");
			Row gapRow = null;
			if (GenerateExcel) {
				gapRow = sheet.createRow(excelRowNumber);
				excelRowNumber++;
				gapRow.createCell(0).setCellValue(periods[periodIndex]);
			}
			for (String column2:columns) {
				if (iDataTable.getSchema().hasColumn(column2)) {
					if (!column2.equals(PeriodColumn)) {
						dataSet.append( "<set rowId='"+replaceSpecialCharacters(column2)+ "' columnId='"+replaceSpecialCharacters(periods[periodIndex])+"' value='0' />\n");
						if (GenerateExcel) {
							gapRow.createCell(seriesExcelColumn.get(column2)).setCellValue(0);
						}
					}
				}
			}
			periodIndex++; // end on the current
		}
		/*
		 * End fill gaps
		 */
		
		/*
		 * Fill gaps on empty resultset
		 */
		if (hasPeriodRange && iDataTable.getRowCount()==0) {
			for(String period:periods) {
				columnSet.append( "<column id='" + replaceSpecialCharacters(period) + "' />\n");
				Row gapRow = null;
				if (GenerateExcel) {
					gapRow = sheet.createRow(excelRowNumber);
					excelRowNumber++;
					gapRow.createCell(0).setCellValue(period);
				}
				for (String column2:columns) {
					if (iDataTable.getSchema().hasColumn(column2)) {
						if (!column2.equals(PeriodColumn)) {
							dataSet.append( "<set rowId='"+replaceSpecialCharacters(column2)+ "' columnId='"+replaceSpecialCharacters(period)+"' value='0' />\n");
							if (GenerateExcel) {
								gapRow.createCell(seriesExcelColumn.get(column2)).setCellValue(0);
							}
						}
					}
				}
			}
		}
		
		if (GenerateExcel) {
			for(int j=headerRow.getFirstCellNum();j<=headerRow.getLastCellNum();j++) {
				sheet.autoSizeColumn(j);
			}
			try {
				File tempFile = File.createTempFile("temp-report-excel", ".xlsx");
			    OutputStream out=new FileOutputStream(tempFile);
			    wb.write(out);
			    out.close();
			    InputStream in = new FileInputStream(tempFile);
				Core.storeFileDocumentContent(context, ReportSelectParameter.getMendixObject(), in);
				ReportSelectParameter.setName("report-excel.xlsx");
			} catch (IOException e){
				Core.getLogger(this.toString()).error("IO Exception " + SharedFunctions.getStackTrace(e));				    	
		    }
		}
		
		
		Long v1 = (maxValue>2?maxValue/3:1);
		Long v2 = (maxValue>2?2*maxValue/3:2);
		Long v3 = (maxValue>2?maxValue:3);
		
		StringBuffer result = new StringBuffer("");
		result.append("<rows>\n").append(rowSet.toString()).append("</rows>\n");
		result.append("<columns>\n").append(columnSet.toString()).append("</columns>\n");
		result.append("<dataset>\n").append(dataSet.toString()).append("</dataset>\n");
		result.append(
				"<colorRange gradient='1' minValue='0' code='FF654F' startlabel='Low' endLabel='Highest'>" +
				"<color code ='028FF6' minValue='0' maxValue='"+v1.toString()+"' label='Medium'/>" +
				"<color code ='8BBA00' minValue='"+v1.toString()+"' maxValue='"+v2.toString()+"' label='High'/>" +
				"<color code ='F6BD0F' minValue='"+v2.toString()+"' maxValue='"+v3.toString()+"' />"+
				"</colorRange>");
		return result.toString();
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@Override
	public java.lang.String toString()
	{
		return "GenerateMSHeatMapReportXMLFromOQL_Java";
	}

	// BEGIN EXTRA CODE
	
	private String replaceSpecialCharacters(String replaceString){
		
		replaceString = replaceString.replaceAll(">","&gt;");
		replaceString = replaceString.replaceAll("<","&lt;");
		replaceString = replaceString.replaceAll("'","&apos;");
		replaceString = replaceString.replaceAll("\"","&quot;");
		
		return replaceString;
	}
	private String replaceSpecialCharacters2(String replaceString){
		
		replaceString = replaceString.replaceAll(">","&gt;");
		replaceString = replaceString.replaceAll("<","&lt;");
		replaceString = replaceString.replaceAll("\"","&quot;");
		// NON HTML Codes, but so need because Fusion Charts interferes
		replaceString = replaceString.replaceAll("'","&apos2;");
		replaceString = replaceString.replaceAll(",","&comma2;");
		
		return replaceString;
	}

	private String getValueString(Object value) {
		if( value==null) {
			return EmptyString;
		} else if(value instanceof String) {
			return (String)value;
		} else if( value instanceof Date) {	    		
			SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", new Locale("nl_NL"));
			java.util.TimeZone timeZone = TimeZone.getDefault();
			simpleDateFormat.setTimeZone(timeZone);
			return simpleDateFormat.format((Date) value);
		} else if( value instanceof Integer) {
			return value.toString();
		} else if( value instanceof Long) {
			return value.toString();
		} else if( value instanceof Boolean) {
			return value.toString();
		} else if( value instanceof Float) {
			return value.toString();
		} else {
			return value.toString();
		}
	}
	// END EXTRA CODE
}
