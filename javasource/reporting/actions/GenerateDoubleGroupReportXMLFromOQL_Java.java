// This file was generated by Mendix Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package reporting.actions;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;
import nl.mansystems.mendiximportexport.SharedFunctions;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.DataFormat;
import org.apache.poi.ss.usermodel.Font;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.util.DateFormatConverter;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import reporting.proxies.TimePeriodEnum;
import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.connectionbus.data.IDataRow;
import com.mendix.systemwideinterfaces.connectionbus.data.IDataTable;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.systemwideinterfaces.core.IMendixObject;
import com.mendix.webui.CustomJavaAction;

/**
 * ColumnList and PeriodList need to be semi-colon separated
 */
public class GenerateDoubleGroupReportXMLFromOQL_Java extends CustomJavaAction<java.lang.String>
{
	private java.lang.String OQLString;
	private java.lang.String ColumnList;
	private java.lang.String PeriodColumn;
	private java.lang.String PeriodList;
	private reporting.proxies.TimePeriodEnum TimePeriod;
	private java.lang.String PeriodColumn2;
	private java.lang.Boolean GenerateExcel;
	private IMendixObject __ReportSelectParameter;
	private reporting.proxies.ReportSelect ReportSelectParameter;
	private java.lang.String EmptyString;

	public GenerateDoubleGroupReportXMLFromOQL_Java(IContext context, java.lang.String OQLString, java.lang.String ColumnList, java.lang.String PeriodColumn, java.lang.String PeriodList, java.lang.String TimePeriod, java.lang.String PeriodColumn2, java.lang.Boolean GenerateExcel, IMendixObject ReportSelectParameter, java.lang.String EmptyString)
	{
		super(context);
		this.OQLString = OQLString;
		this.ColumnList = ColumnList;
		this.PeriodColumn = PeriodColumn;
		this.PeriodList = PeriodList;
		this.TimePeriod = TimePeriod == null ? null : reporting.proxies.TimePeriodEnum.valueOf(TimePeriod);
		this.PeriodColumn2 = PeriodColumn2;
		this.GenerateExcel = GenerateExcel;
		this.__ReportSelectParameter = ReportSelectParameter;
		this.EmptyString = EmptyString;
	}

	@Override
	public java.lang.String executeAction() throws Exception
	{
		this.ReportSelectParameter = __ReportSelectParameter == null ? null : reporting.proxies.ReportSelect.initialize(getContext(), __ReportSelectParameter);

		// BEGIN USER CODE
		IContext context = this.getContext();
		
		Workbook wb = null;
		Sheet sheet = null;
		Row headerRow = null;
		CellStyle csHeader = null;
		CellStyle csString = null;
		CellStyle csDate = null;

		if (GenerateExcel) {
			wb = new SXSSFWorkbook();
			csHeader = wb.createCellStyle();
			Font fontHeader = wb.createFont();
			fontHeader.setBoldweight(Font.BOLDWEIGHT_BOLD);
			csHeader.setFont(fontHeader);

			csString = wb.createCellStyle();
			csDate = wb.createCellStyle();
			Font fontBody = wb.createFont();
			fontBody.setFontHeightInPoints((short) 11);
			csString.setFont(fontBody);
			csDate.setFont(fontBody);

			Locale locale = Locale.getDefault();
			DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, locale);
			String javaDateFormatPattern = ((SimpleDateFormat)dateFormat).toPattern();
		    String excelFormatPattern = DateFormatConverter.convert(locale, javaDateFormatPattern);
			DataFormat dfDate = wb.createDataFormat();
			csDate.setDataFormat(dfDate.getFormat(excelFormatPattern));

			sheet = wb.createSheet("Results");
			headerRow = sheet.createRow(0);
			Cell cell = headerRow.createCell(0);
			cell.setCellValue(PeriodColumn);
			cell.setCellStyle(csHeader);
		}

		Core.getLogger("DynamicOQL").debug("Retrieving data");
		if (PeriodList!=null) Core.getLogger("DynamicOQL").trace("PeriodList:" + PeriodList);
		Core.getLogger("DynamicOQL").trace("OQL:" + OQLString);
		IDataTable iDataTable = Core.retrieveOQLDataTable(context, OQLString);
		String[] columns = ColumnList.split(";");
		boolean hasPeriodRange = false;
		int periodIndex=0;
		String[] periods=null;
		if (PeriodList!=null) {
			periods = PeriodList.split(";");
			hasPeriodRange = true;
		}
		
		Set<String> series = new LinkedHashSet<String>(); // so insertion order is guaranteed
		Set<String> categories = new LinkedHashSet<String>(); // so insertion order is guaranteed
		StringBuffer categoryXML = new StringBuffer(); 
		categoryXML.append("<categories>\n");
		Map<String,StringBuffer> category2XML = new HashMap<String,StringBuffer>();
		Map<String,Map<String,Object>> category2Values = new HashMap<String,Map<String,Object>>();
		Map<String,Integer> seriesExcelColumn = new HashMap<String,Integer>();
		int excelColumn=1;

		String valueColumn = null;
		for (String column:columns) {
			if (iDataTable.getSchema().hasColumn(column)) {
				if (!column.equals(PeriodColumn) && !column.equals(PeriodColumn2)) valueColumn = column;
			}
		}
		
		/*
		 * First determine all series and collect all values.
		 */
		String groupByStr ="";
		for (IDataRow dataRow:iDataTable.getRows()) {
			Object object = dataRow.getValue(context, PeriodColumn);
			groupByStr = (object==null?EmptyString:object.toString());
			if(!(groupByStr.equals(EmptyString)) && TimePeriod!=null){
				String yearStr = groupByStr.substring(0,4);
				if (TimePeriod == TimePeriodEnum.Year) {
					groupByStr = yearStr;
				}else if (TimePeriod == TimePeriodEnum.Quarter) {
					String monthStr = groupByStr.substring(4,5);
					groupByStr = yearStr + "-" + monthStr;
				}else if (TimePeriod == TimePeriodEnum.Month) {
					String monthStr = groupByStr.substring(4,6);
					groupByStr = yearStr + "-" + monthStr;
				}else if(TimePeriod == TimePeriodEnum.Week){
					String weekStr = groupByStr.substring(4,6);
					groupByStr = yearStr + "-" + weekStr;
				}else if (TimePeriod == TimePeriodEnum.Day) {	
					String monthStr = groupByStr.substring(4,6);
					String dayStr =  groupByStr.substring(6,8);
					groupByStr = yearStr + "-" + monthStr + "-" + dayStr;
				}else if (TimePeriod == TimePeriodEnum.Hour) {	
					String monthStr = groupByStr.substring(4,6);
					String dayStr =  groupByStr.substring(6,8);
					String hourStr =  groupByStr.substring(8,10);
					groupByStr = yearStr + "-" + monthStr + "-" + dayStr + " " + hourStr;
				}else if (TimePeriod == TimePeriodEnum.Minute) {	
					String monthStr = groupByStr.substring(4,6);
					String dayStr =  groupByStr.substring(6,8);
					String hourStr =  groupByStr.substring(8,10);
					String minuteStr =  groupByStr.substring(10,12);
					groupByStr = yearStr + "-" + monthStr + "-" + dayStr + " " + hourStr + ":" + minuteStr;
				}else if (TimePeriod == TimePeriodEnum.Second) {	
					String monthStr = groupByStr.substring(4,6);
					String dayStr =  groupByStr.substring(6,8);
					String hourStr =  groupByStr.substring(8,10);
					String minuteStr =  groupByStr.substring(10,12);
					String secondStr =  groupByStr.substring(12,14);
					groupByStr = yearStr + "-" + monthStr + "-" + dayStr + " " + hourStr + ":" + minuteStr + ":" + secondStr;
				}	
			}
			
			categories.add(groupByStr);
			
			Object object2 = dataRow.getValue(context, PeriodColumn2);
			String serieStr = (object2==null?EmptyString:object2.toString());

			Object object3 = dataRow.getValue(context, valueColumn);

			if (!series.contains(serieStr)) series.add(serieStr);
			
			if (!category2XML.containsKey(serieStr)) {
				category2XML.put(serieStr, new StringBuffer("<dataset seriesName=\""+replaceSpecialCharacters(serieStr)+"\">\n"));
			}
			if (category2Values.containsKey(groupByStr)) {
					category2Values.get(groupByStr).put(serieStr, object3);
			} else {
				category2Values.put(groupByStr, new HashMap<String,Object>());
				category2Values.get(groupByStr).put(serieStr, object3);
			}
		}
		
		// Fill header row here!!! as well as Map string to column id
		if (GenerateExcel) {
			for (String column:series) {
				Cell cell = headerRow.createCell(excelColumn);
				cell.setCellValue(column);
				cell.setCellStyle(csHeader);						
				seriesExcelColumn.put(column, excelColumn);
				excelColumn++;
			}
		}
		
		int excelRow=1;
		Row row = null;
		
		String lastPeriod = "";
		for (String periodStr:categories) {
			/*
			 * Fill gaps
			 */
			
			if(periodStr != null){
				while (hasPeriodRange && periodIndex < periods.length && periods[periodIndex].compareTo(periodStr)<0) {
					categoryXML.append( "<category label=\"" +replaceSpecialCharacters(periods[periodIndex]) + "\" />\n");
					//categories.add(periods[periodIndex]);
					Row gapRow = null;
					if (GenerateExcel) {
						gapRow = sheet.createRow(excelRow);
						excelRow++;
						gapRow.createCell(0).setCellValue(periods[periodIndex]);
					}
					for (String column:series) {
						category2XML.get(column).append("<set value=\"0\" />\n");
						if (GenerateExcel) {
							gapRow.createCell(seriesExcelColumn.get(column)).setCellValue(0);
						}
					}
					periodIndex++; // end on the current
				}
				periodIndex++; // every time there is no gap the periodIndex needs to advance.
				/*
				 * End fill gaps
				 */
				categoryXML.append( "<category label=\"" + replaceSpecialCharacters(periodStr) + "\" />\n");
				//categories.add(periodStr);
				
				if (GenerateExcel) {
					row = sheet.createRow(excelRow);
					excelRow++;
					row.createCell(0).setCellValue(periodStr);
				}
				for (String column:series) {
					Object value = null;
					String valueStr = null;
					if (category2Values.get(periodStr).containsKey(column)) {
						value = category2Values.get(periodStr).get(column);
						valueStr = getValueString(value);
						category2XML.get(column).append("<set value=\"" + valueStr+ "\" link=\"JavaScript:fusionCallback('#widgetid#','drillDown','"
								+replaceSpecialCharacters2(periodStr)+","+replaceSpecialCharacters2(column)+","+valueStr+"');\" />\n");
						if (GenerateExcel) {
							Cell cell = row.createCell(seriesExcelColumn.get(column));
							if( value==null) {
								cell.setCellValue(EmptyString);
								cell.setCellStyle(csString);
							} else if(value instanceof String) {
								cell.setCellValue((String)value);
								cell.setCellStyle(csString);
							} else if( value instanceof Date) {
								cell.setCellValue((Date)value);
								cell.setCellStyle(csDate);
							} else if( value instanceof Integer) {
								cell.setCellValue((Integer)value);
								cell.setCellStyle(csString);
							} else if( value instanceof Long) {
								cell.setCellValue((Long)value);
								cell.setCellStyle(csString);
							} else if( value instanceof Boolean) {
								cell.setCellValue((Boolean)value);
								cell.setCellStyle(csString);
							} else if( value instanceof Float) {
								cell.setCellValue((Float)value);
								cell.setCellStyle(csString);
							} else {
								cell.setCellValue(value.toString());
								cell.setCellStyle(csString);
							}						}
					} else {
						category2XML.get(column).append("<set value=\"0\" />\n");
						if (GenerateExcel) {
							row.createCell(seriesExcelColumn.get(column)).setCellValue(0);
						}
					}
				}
				lastPeriod = periodStr;
			}
		}

		/*
		 * Fill gaps
		 */
		while (hasPeriodRange && periodIndex < periods.length && periods[periodIndex].compareTo(lastPeriod)>=0) {
			categoryXML.append( "<category label=\"" + replaceSpecialCharacters(periods[periodIndex]) + "\" />\n");
			//categories.add(periods[periodIndex]);
			Row gapRow = null;
			if (GenerateExcel) {
				gapRow = sheet.createRow(excelRow);
				excelRow++;
				gapRow.createCell(0).setCellValue(periods[periodIndex]);
			}
			for (String column:series) {
				category2XML.get(column).append("<set value=\"0\" />\n");
				if (GenerateExcel) {
					gapRow.createCell(seriesExcelColumn.get(column)).setCellValue(0);
				}
			}
			periodIndex++; // end on the current
		}
		/*
		 * End fill gaps
		 */
		
		/*
		 * Fill gaps on empty resultset
		 */
		if (hasPeriodRange && iDataTable.getRowCount()==0) {
			for(String period:periods) {
				categoryXML.append( "<category label=\"" + replaceSpecialCharacters(period) + "\" />\n");
				Row gapRow = null;
				if (GenerateExcel) {
					gapRow = sheet.createRow(excelRow);
					excelRow++;
					gapRow.createCell(0).setCellValue(period);
				}
				for (String column:series) {
					category2XML.get(column).append("<set value=\"0\" />\n");
					if (GenerateExcel) {
						gapRow.createCell(seriesExcelColumn.get(column)).setCellValue(0);
					}
				}
			}
		}
		
		if (GenerateExcel) {
			for(int j=headerRow.getFirstCellNum();j<=headerRow.getLastCellNum();j++) {
				sheet.autoSizeColumn(j);
			}
			try {
				File tempFile = File.createTempFile("temp-report-excel", ".xlsx");
			    OutputStream out=new FileOutputStream(tempFile);
			    wb.write(out);
			    out.close();
			    InputStream in = new FileInputStream(tempFile);
				Core.storeFileDocumentContent(context, ReportSelectParameter.getMendixObject(), in);
				ReportSelectParameter.setName("report-excel.xlsx");
			} catch (IOException e){
				Core.getLogger(this.toString()).error("IO Exception " + SharedFunctions.getStackTrace(e));				    	
		    }
		}
		
		
		categoryXML.append("</categories>\n");
		StringBuffer result = new StringBuffer();
		result.append(categoryXML.toString());
		for (String column:series) {
			category2XML.get(column).append("</dataset>\n");
			result.append(category2XML.get(column).toString());
		}
		return result.toString();
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@Override
	public java.lang.String toString()
	{
		return "GenerateDoubleGroupReportXMLFromOQL_Java";
	}

	// BEGIN EXTRA CODE
	private String replaceSpecialCharacters(String replaceString){
		
		replaceString = replaceString.replaceAll(">","&gt;");
		replaceString = replaceString.replaceAll("<","&lt;");
		replaceString = replaceString.replaceAll("'","&apos;");
		replaceString = replaceString.replaceAll("\"","&quot;");
		
		return replaceString;
	}
	private String replaceSpecialCharacters2(String replaceString){
		
		replaceString = replaceString.replaceAll(">","&gt;");
		replaceString = replaceString.replaceAll("<","&lt;");
		replaceString = replaceString.replaceAll("\"","&quot;");
		// NON HTML Codes, but so need because Fusion Charts interferes
		replaceString = replaceString.replaceAll("'","&apos2;");
		replaceString = replaceString.replaceAll(",","&comma2;");
		
		return replaceString;
	}

	private String getValueString(Object value) {
		if( value==null) {
			return EmptyString;
		} else if(value instanceof String) {
			return (String)value;
		} else if( value instanceof Date) {	    		
			SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS", new Locale("nl_NL"));
			java.util.TimeZone timeZone = TimeZone.getDefault();
			simpleDateFormat.setTimeZone(timeZone);
			return simpleDateFormat.format((Date) value);
		} else if( value instanceof Integer) {
			return value.toString();
		} else if( value instanceof Long) {
			return value.toString();
		} else if( value instanceof Boolean) {
			return value.toString();
		} else if( value instanceof Float) {
			return value.toString();
		} else {
			return value.toString();
		}
	}
	// END EXTRA CODE
}
