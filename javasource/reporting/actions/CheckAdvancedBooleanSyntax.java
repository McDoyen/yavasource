// This file was generated by Mendix Modeler.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package reporting.actions;

import org.antlr.runtime.*;
import org.apache.commons.lang.StringUtils;
import reporting.booleanparser.*;
import com.mendix.core.Core;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;

public class CheckAdvancedBooleanSyntax extends CustomJavaAction<java.lang.String>
{
	private java.lang.String BooleanStringPar;
	private java.lang.String FilterIDStringList;
	private java.lang.String ErrorMessageTemplate;
	private java.lang.String ErrorBracesTemplate;
	private java.lang.String ErrorTokenTemplate;
	private java.lang.String ErrorMissingIDTemplate;
	private java.lang.String ErrorExtraIDTemplate;

	public CheckAdvancedBooleanSyntax(IContext context, java.lang.String BooleanStringPar, java.lang.String FilterIDStringList, java.lang.String ErrorMessageTemplate, java.lang.String ErrorBracesTemplate, java.lang.String ErrorTokenTemplate, java.lang.String ErrorMissingIDTemplate, java.lang.String ErrorExtraIDTemplate)
	{
		super(context);
		this.BooleanStringPar = BooleanStringPar;
		this.FilterIDStringList = FilterIDStringList;
		this.ErrorMessageTemplate = ErrorMessageTemplate;
		this.ErrorBracesTemplate = ErrorBracesTemplate;
		this.ErrorTokenTemplate = ErrorTokenTemplate;
		this.ErrorMissingIDTemplate = ErrorMissingIDTemplate;
		this.ErrorExtraIDTemplate = ErrorExtraIDTemplate;
	}

	@Override
	public java.lang.String executeAction() throws Exception
	{
		// BEGIN USER CODE
	    try {
	        //lexer splits input into tokens
	    	if (BooleanStringPar==null) return "An Advanced Filter is required"; // Should not happen. is checked in microflow.
			Core.getLogger(this.toString()).trace("Input: " +BooleanStringPar);

	        ANTLRStringStream input = new ANTLRStringStream(BooleanStringPar);
	        BooleanLexer lexer = new BooleanLexer( input );
	        TokenStream tokens = new CommonTokenStream( lexer );

	        //parser generates abstract syntax tree
	        BooleanParser parser = new BooleanParser(tokens);
	        parser.eval();

	        // If errors loop over token stream to find error and get line+pos and return. Also return whether it is a lexer or parser error
	        // and whether braces match
        	boolean lexerError = (lexer.getNumberOfSyntaxErrors()>0?true:false);
        	boolean parserError = (parser.getNumberOfSyntaxErrors()>0?true:false);
        	boolean error = lexerError || parserError;
        	boolean bracesMismatch = false;
        	int errorLine = 0;
        	int errorPos = 0;
        	int countOpenBraces = StringUtils.countMatches(BooleanStringPar,"(");
        	int countCloseBraces = StringUtils.countMatches(BooleanStringPar,")");
        	String errorToken = null;
        	if(countOpenBraces!=countCloseBraces) {
        		bracesMismatch = true;
        	}
	        if (lexer.getNumberOfSyntaxErrors()>0 || parser.getNumberOfSyntaxErrors()>0) {
	        	int size = parser.getTokenStream().range();
		        for(int i=0;i<=size;i++) {
	        		Token token = parser.getTokenStream().get(i);
		        	Core.getLogger(this.toString()).trace("Token: " + token.getText() + " of type " + token.getType());
	        		if (token.getType() == BooleanLexer.NOT_ALLOWED) {
	    	        	Core.getLogger(this.toString()).trace("Invalid Token: " + token.getText());
        				errorLine = token.getLine();
        				errorPos = token.getCharPositionInLine();
        				errorToken = token.getText();
	        			break;
	        		}
		        }
		        if (errorToken==null) {
		        	Token token = parser.getTokenStream().get(size-1);
    				errorLine = token.getLine();
    				errorPos = token.getCharPositionInLine();
    				errorToken = token.getText();
		        }
	        }
	        
	        if (error) {
	        	String tokenMessage = ErrorTokenTemplate.replace("##TOKEN##", errorToken);
	        	String errorMessage = ErrorMessageTemplate.replace("##TOKEN-TEXT##", tokenMessage);
	        	errorMessage = errorMessage.replace("##LINE##", ""+errorLine);
	        	errorMessage = errorMessage.replace("##POS##", ""+errorPos);
	        	if (bracesMismatch) errorMessage = errorMessage + "\n" + ErrorBracesTemplate;
	        	return errorMessage;
	        }
	        
	        // Now check valid numbers
	        String errorFilterID = "";
	        for(int i=0;i<=parser.getTokenStream().range();i++) {
        		Token token = parser.getTokenStream().get(i);
	        	Core.getLogger(this.toString()).trace("Token: " + token);
	        	if (token.getText().matches("[0-9]+") && !FilterIDStringList.contains(";"+token.getText()+";")) {
		        	errorFilterID = errorFilterID + ErrorExtraIDTemplate.replace("##TOKEN##", token.getText()).replace("##LINE##", ""+token.getLine()).replace("##POS##", ""+token.getCharPositionInLine());		        		
	        	}
	        }
	        for(String filterID:FilterIDStringList.split(";")) {
	        	if (filterID.equals("")) continue; // skip ; at beginning and end.
	        	boolean found = false;
		        for(int i=0;i<parser.getTokenStream().range();i++) { // skip EOF with <
	        		Token token = parser.getTokenStream().get(i);
		        	if (token.getText().equals(filterID)) {
		        		found = true;
		        	}
		        }
		        if (!found) {
		        	errorFilterID = errorFilterID + ErrorMissingIDTemplate.replace("##TOKEN##", filterID);		        		
		        }
		        
	        }
			Core.getLogger(this.toString()).trace("Output: " +errorFilterID);
	        if (!errorFilterID.equals("")) return errorFilterID;
	    } catch (RecognitionException e) {
        	boolean bracesMismatch = false;
        	int countOpenBraces = StringUtils.countMatches(BooleanStringPar,"(");
        	int countCloseBraces = StringUtils.countMatches(BooleanStringPar,")");
        	if(countOpenBraces!=countCloseBraces) {
        		bracesMismatch = true;
        	}

        	String tokenMessage = ErrorTokenTemplate.replace("##TOKEN##", e.token.getText() );
        	String errorMessage = ErrorMessageTemplate.replace("##TOKEN-TEXT##", tokenMessage);
        	errorMessage = errorMessage.replace("##LINE##", ""+e.line);
        	errorMessage = errorMessage.replace("##POS##", ""+e.charPositionInLine);
        	if (bracesMismatch) errorMessage = errorMessage + "\n" + ErrorBracesTemplate;
        	return errorMessage;
	    }
	    return null;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 */
	@Override
	public java.lang.String toString()
	{
		return "CheckAdvancedBooleanSyntax";
	}

	// BEGIN EXTRA CODE
	// END EXTRA CODE
}
